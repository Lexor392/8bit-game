function buildGameButton() { if ($(window).focus(function () { buttonSoundOn.visible || toggleSoundInMute(!1), "undefined" != typeof buttonMusicOn && (buttonMusicOn.visible || toggleMusicInMute(!1)) }), $(window).blur(function () { buttonSoundOn.visible || toggleSoundInMute(!0), "undefined" != typeof buttonMusicOn && (buttonMusicOn.visible || toggleMusicInMute(!0)) }), $.browser.mobile || isTablet); else { var a = window.location != window.parent.location; a ? (this.document.onkeydown = keydown, this.document.onkeyup = keyup, $(window).blur(function () { appendFocusFrame() }), appendFocusFrame()) : (this.document.onkeydown = keydown, this.document.onkeyup = keyup) } buttonLocal.cursor = "pointer", buttonLocal.addEventListener("click", function (a) { playSound("soundButton"), socketData.online = !1, goPage("select") }), buttonOnline.cursor = "pointer", buttonOnline.addEventListener("click", function (a) { playSound("soundButton"), checkQuickGameMode() }), buttonStart.cursor = "pointer", buttonStart.addEventListener("click", function (a) { playSound("soundButton"), "function" == typeof initSocket && multiplayerSettings.enable ? multiplayerSettings.localPlay ? toggleMainButton("local") : checkQuickGameMode() : goPage("select") }), buttonLeft.cursor = "pointer", buttonLeft.addEventListener("click", function (a) { playSound("soundButton"), toggleGameMap(!1) }), buttonRight.cursor = "pointer", buttonRight.addEventListener("click", function (a) { playSound("soundButton"), toggleGameMap(!0) }), buttonLeftSmall.cursor = "pointer", buttonLeftSmall.addEventListener("click", function (a) { playSound("soundButton"), toggleGameMapTheme(!1) }), buttonRightSmall.cursor = "pointer", buttonRightSmall.addEventListener("click", function (a) { playSound("soundButton"), toggleGameMapTheme(!0) }), buttonSelect.cursor = "pointer", buttonSelect.addEventListener("click", function (a) { playSound("soundButton"), "function" == typeof initSocket && multiplayerSettings.enable && socketData.online ? socketData.host && postSocketUpdate("start") : goPage("game") }), itemExit.addEventListener("click", function (a) { }), buttonContinue.cursor = "pointer", buttonContinue.addEventListener("click", function (a) { playSound("soundButton"), "function" == typeof initSocket && multiplayerSettings.enable && socketData.online && multiplayerSettings.rejoinRoom ? (goPage("room"), $("#roomlists").val(socketData.lastRoom), joinSocketRoom()) : goPage("main") }), buttonTwitter.cursor = "pointer", buttonTwitter.addEventListener("click", function (a) { share("twitter") }), buttonSoundOff.cursor = "pointer", buttonSoundOff.addEventListener("click", function (a) { toggleSoundMute(!0) }), buttonSoundOn.cursor = "pointer", buttonSoundOn.addEventListener("click", function (a) { toggleSoundMute(!1) }), "undefined" != typeof buttonMusicOff && (buttonMusicOff.cursor = "pointer", buttonMusicOff.addEventListener("click", function (a) { toggleMusicMute(!0) })), "undefined" != typeof buttonMusicOn && (buttonMusicOn.cursor = "pointer", buttonMusicOn.addEventListener("click", function (a) { toggleMusicMute(!1) })), buttonFullscreen.cursor = "pointer", buttonFullscreen.addEventListener("click", function (a) { toggleFullScreen() }), buttonExit.cursor = "pointer", buttonExit.addEventListener("click", function (a) { togglePop(!0), toggleOption() }), buttonSettings.cursor = "pointer", buttonSettings.addEventListener("click", function (a) { toggleOption() }), buttonConfirm.cursor = "pointer", buttonConfirm.addEventListener("click", function (a) { playSound("soundButton"), togglePop(!1), stopAudio(), stopGame(), goPage("main"), "function" == typeof initSocket && multiplayerSettings.enable && socketData.online && exitSocketRoom() }), buttonCancel.cursor = "pointer", buttonCancel.addEventListener("click", function (a) { playSound("soundButton"), togglePop(!1) }), setupTouchControl(), preventScrolling() } function preventScrolling() { var a = [32, 38, 37, 40, 39]; $(window).on("keydown", function (e) { -1 != a.indexOf(e.keyCode) && e.preventDefault() }) } function appendFocusFrame() { $("#mainHolder").prepend('<div id="focus" style="position:absolute; width:100%; height:100%; z-index:1000;"></div'), $("#focus").click(function () { $("#focus").remove() }) } function toggleMainButton(a) { "function" == typeof initSocket && multiplayerSettings.enable && (gameLogsTxt.visible = !0, gameLogsTxt.text = ""), buttonStart.visible = !1, buttonLocalContainer.visible = !1, "start" == a ? buttonStart.visible = !0 : "local" == a && (buttonLocalContainer.visible = !0) } function checkQuickGameMode() { socketData.online = !0, multiplayerSettings.enterName ? goPage("name") : (buttonStart.visible = !1, buttonLocalContainer.visible = !1, addSocketRandomUser()) } function toggleGameMap(a) { a ? (gameData.mapNum++, gameData.mapNum = gameData.mapNum > maps_arr.length - 1 ? 0 : gameData.mapNum) : (gameData.mapNum--, gameData.mapNum = gameData.mapNum < 0 ? maps_arr.length - 1 : gameData.mapNum), prepareGame(), "function" == typeof initSocket && multiplayerSettings.enable && socketData.online && postSocketUpdate("preparegame", { map: gameData.mapNum, theme: gameData.themeNum }, !0) } function toggleGameMapTheme(a) { a ? (gameData.themeNum++, gameData.themeNum = gameData.themeNum > theme_settings.length - 1 ? 0 : gameData.themeNum) : (gameData.themeNum--, gameData.themeNum = gameData.themeNum < 0 ? theme_settings.length - 1 : gameData.themeNum), prepareGame(), "function" == typeof initSocket && multiplayerSettings.enable && socketData.online && postSocketUpdate("preparegame", { map: gameData.mapNum, theme: gameData.themeNum }, !0) } function keydown(a) { "game" == curPage && (-1 != mapSettings.keyboard.left.indexOf(a.keyCode) ? gameData.moveControl.left = !0 : -1 != mapSettings.keyboard.right.indexOf(a.keyCode) ? gameData.moveControl.right = !0 : -1 != mapSettings.keyboard.up.indexOf(a.keyCode) ? gameData.moveControl.up = !0 : -1 != mapSettings.keyboard.down.indexOf(a.keyCode) && (gameData.moveControl.down = !0)), $.editor.enable && (90 == a.keyCode ? editData.backward = !0 : 65 == a.keyCode ? toggleWallSelect(!1) : 83 == a.keyCode ? toggleWallSelect(!0) : 81 == a.keyCode && $("#replaceBlock").trigger("click")) } function keyup(a) { "game" == curPage && (-1 != mapSettings.keyboard.left.indexOf(a.keyCode) ? gameData.moveControl.left = !1 : -1 != mapSettings.keyboard.right.indexOf(a.keyCode) ? gameData.moveControl.right = !1 : -1 != mapSettings.keyboard.up.indexOf(a.keyCode) ? gameData.moveControl.up = !1 : -1 != mapSettings.keyboard.down.indexOf(a.keyCode) && (gameData.moveControl.down = !1)), $.editor.enable && (editData.backward = !1) } function resizeSocketLog() { "main" == curPage ? (viewport.isLandscape, gameLogsTxt.x = canvasW / 2, gameLogsTxt.y = canvasH / 100 * 75) : "custom" == curPage && (viewport.isLandscape ? (gameLogsTxt.x = canvasW / 2, gameLogsTxt.y = canvasH / 100 * 67) : (gameLogsTxt.x = canvasW / 2, gameLogsTxt.y = canvasH / 100 * 65)) } function togglePop(a) { confirmContainer.visible = a } function goPage(a) { curPage = a, $("#roomWrapper").hide(), $("#roomWrapper .innerContent").hide(), gameLogsTxt.visible = !1, mainContainer.visible = !1, nameContainer.visible = !1, roomContainer.visible = !1, selectContainer.visible = !1, mapContainer.visible = !1, gameContainer.visible = !1, resultContainer.visible = !1; var e = null; switch (a) { case "main": e = mainContainer, toggleMainButton("start"); break; case "name": e = nameContainer, $("#roomWrapper").show(), $("#roomWrapper .nameContent").show(), $("#roomWrapper .fontNameError").html(""), $("#enterName").show(); break; case "room": e = roomContainer, $("#roomWrapper").show(), $("#roomWrapper .roomContent").show(), switchSocketRoomContent("lists"); break; case "select": e = selectContainer, mapContainer.visible = !0, buttonSelect.visible = !0, buttonLeft.visible = buttonRight.visible = !0, buttonLeftSmall.visible = buttonRightSmall.visible = !0, "function" == typeof initSocket && multiplayerSettings.enable && socketData.online ? socketData.host || (buttonSelect.visible = !1, buttonLeft.visible = buttonRight.visible = !1, buttonLeftSmall.visible = buttonRightSmall.visible = !1) : (gameData.gameIndex = 0, gameData.mapLoopSide = randomBoolean()), prepareGame(); break; case "game": e = gameContainer, mapContainer.visible = !0, startGame(); break; case "result": e = resultContainer, stopGame(), togglePop(!1), playSound("soundResult"), saveGame(playerData.score), TweenMax.to(tweenData, .5, { tweenScore: playerData.score, overwrite: !0, onUpdate: function () { var a = addCommas(Math.floor(tweenData.tweenScore)); resultDescTxt.text = textDisplay.resultDesc.replace("[NUMBER]", a) } }), "function" == typeof initSocket && multiplayerSettings.enable && socketData.online && (socketData.host ? postSocketCloseRoom() : exitSocketRoom()) }null != e && (e.visible = !0, e.alpha = 0, TweenMax.to(e, .5, { alpha: 1, overwrite: !0 })), resizeCanvas() } function startGame() { setGameDefault(), prepareGame(), $.editor.enable ? gameData.paused = !0 : (touchContainer.visible = !1, mapSettings.showScreenControl ? (touchContainer.visible = !0, touchContainer.alpha = mapSettings.screenControlAlpha) : ($.browser.mobile || isTablet) && (touchContainer.visible = !0, touchContainer.alpha = mapSettings.screenControlAlpha), "function" == typeof initSocket && multiplayerSettings.enable && socketData.online ? socketData.host && postSocketUpdate("countdown", !0) : startCountdown(!0)) } function stopGame() { gameData.paused = !0, toggleGameTimer(!1), toggleGameSound(""), TweenMax.killAll(!1, !0, !1) } function saveGame(a) { "function" == typeof toggleScoreboardSave && ($.scoreData.score = a, "undefined" != typeof type && ($.scoreData.type = type), toggleScoreboardSave(!0)) } function setGameDefault() { if (playerData.score = 0, gameData.level = 0, gameData.lives = mapSettings.lives, gameData.moveControl = { left: !1, right: !1, up: !1, down: !1 }, "function" == typeof initSocket && multiplayerSettings.enable && socketData.online && gameData.mapLoop) for (var a = 0; a < socketData.players.length; a++)socketData.players[a].lives = 1 } function prepareGame() { multiData.players = [], multiData.loopCount = 0, gameData.multiPosIndex = 0, gameData.userSpeed = mapSettings.userSpeed, gameData.ghostSpeed = mapSettings.ghostSpeed, gameData.ghostEatenSpeed = mapSettings.ghostEatenSpeed, gameData.ghostEatableSpeed = mapSettings.ghostEatableSpeed, gameData.squareSize = mapSettings.squareSize, gameData.monsterSize = mapSettings.monsterSize, gameData.totalGhosts = maps_arr[gameData.mapNum].totalGhosts, gameData.ghostBlink = !1, gameData.totalEaten = 0, gameData.mapLoop = !1, gameData.collected = [], itemBroken.visible = !1, resetTimer(); var a = !1; $.editor.enable ? editData.testPlay && (a = !0) : a = !0, a && (gameData.mapLoop = "" != maps_arr[gameData.mapNum].loop, gameData.mapLoop && (gameData.lives = 1, gameData.pillTarget = 0, gameData.collectionTarget = 0, "horizontal" == maps_arr[gameData.mapNum].loop ? gameData.mapLoopDirection = 1 == gameData.mapLoopSide ? "left" : "right" : "vertical" == maps_arr[gameData.mapNum].loop && (gameData.mapLoopDirection = 1 == gameData.mapLoopSide ? "up" : "down"), itemBroken.visible = !0, getLevelSettings())), buildMap(), updateGameDisplay() } function buildMap() { mapPlayersContainer.removeAllChildren(), mapMultiPlayersContainer.removeAllChildren(), mapLabelsContainer.removeAllChildren(), mapMultiLabelsContainer.removeAllChildren(), mapCollectContainer.removeAllChildren(), gameData.startPos = maps_arr[gameData.mapNum].startPos, gameData.ghostPos = maps_arr[gameData.mapNum].ghostPos, gameData.ghostStayPos = maps_arr[gameData.mapNum].ghostStayPos, gameData.multiPos = maps_arr[gameData.mapNum].multiPos, gameData.multiPosIndex = 0, gameData.pathArray = [], gameData.map = [], gameData.mapExtraX = 0, gameData.mapExtraY = 0, gameData.mapLoopH = 0, gameData.mapLoopW = 0, gameData.replaceIndex = 0, gameData.mapLoop && ("down" == gameData.mapLoopDirection ? (gameData.replaceIndex = maps_arr[gameData.mapNum].map.length - 1, gameData.mapExtraY = 2, insertMapRow(!0), insertMapBlock(!0), gameData.mapLoopH = 4) : "up" == gameData.mapLoopDirection && (gameData.replaceIndex = 0, gameData.mapExtraY = 1, insertMapBlock(!0), gameData.mapLoopH = 4)); for (var a = 0; a < maps_arr[gameData.mapNum].map.length; a++) { gameData.map[a + gameData.mapExtraY] = []; for (var e = 0; e < maps_arr[gameData.mapNum].map[a].length; e++)gameData.map[a + gameData.mapExtraY][e + gameData.mapExtraX] = maps_arr[gameData.mapNum].map[a][e], gameData.map[a + gameData.mapExtraY][e + gameData.mapExtraX] == mapType.biscuit ? (gameData.pathArray.push({ x: e + gameData.mapExtraX, y: a + gameData.mapExtraY }), gameData.totalEaten++) : gameData.map[a + gameData.mapExtraY][e + gameData.mapExtraX] == mapType.pill && (gameData.mapLoop && (gameData.map[a + gameData.mapExtraY][e + gameData.mapExtraX] = mapType.biscuit), gameData.pathArray.push({ x: e + gameData.mapExtraX, y: a + gameData.mapExtraY }), gameData.totalEaten++) } if (mapWrapContainer.x = 0, mapWrapContainer.y = 0, gameData.mapLoop && ("down" == gameData.mapLoopDirection ? (insertMapBlock(!1), mapWrapContainer.y -= 2 * gameData.squareSize) : "up" == gameData.mapLoopDirection ? (insertMapRow(!1), insertMapBlock(!1), mapWrapContainer.y -= gameData.squareSize) : "left" == gameData.mapLoopDirection ? (gameData.replaceIndex = maps_arr[gameData.mapNum].map[0].length - 1, gameData.mapExtraX = 2, insertMapColumn(!0), insertMapBlock(!0), gameData.mapLoopW = 4, insertMapBlock(!1), mapWrapContainer.x -= 2 * gameData.squareSize) : "right" == gameData.mapLoopDirection && (gameData.replaceIndex = 0, gameData.mapExtraX = 1, insertMapBlock(!0), gameData.mapLoopW = 4, insertMapColumn(!1), insertMapBlock(!1), mapWrapContainer.x -= gameData.squareSize)), gameData.eaten = 0, gameData.mapW = maps_arr[gameData.mapNum].map[0].length, gameData.mapH = maps_arr[gameData.mapNum].map.length, gameData.pathArrayIndex = 0, shuffle(gameData.pathArray), drawWalls(), drawIcons(), resizeMap(), createGhosts(), resetGhosts(), gameData.users = [], "function" == typeof initSocket && multiplayerSettings.enable && socketData.online) { for (var t = 0, o = 0; o < socketData.players.length; o++)if (createPacman(t), resetPacman(o), t++, t = t > theme_settings[gameData.themeNum].user.length - 1 ? 0 : t, 0 == socketData.players[o].lives) { var n = gameData.users[o]; n.active = !1, n.alpha = 0, n.nameLabel.text = "" } } else createPacman(0), resetPacman(0) } function resizeMap() { mapContainer.scaleX = mapContainer.scaleY = 1; var a = gameData.mapW * gameData.squareSize, e = gameData.mapH * gameData.squareSize, t = 850, o = 600, n = 1, r = 1; viewport.isLandscape || (t = 540, o = 540), e > o && (n = o / e), a > t && (r = t / a), mapContainer.scaleX = mapContainer.scaleY = r < n ? r : n, mapContainer.x = canvasW / 2 - (a / 2 - gameData.squareSize / 2) * mapContainer.scaleX, mapContainer.y = canvasH / 2 - (e / 2 - gameData.squareSize / 2) * mapContainer.scaleX, gameStatusTxt.x = canvasW / 2, gameStatusTxt.y = canvasH / 2, gameScoreTxt.textAlign = "left", gameLevelTxt.textAlign = "left", viewport.isLandscape ? (gameScoreTxt.x = offset.x + 50, gameScoreTxt.y = canvasH / 100 * 44, gameLevelTxt.x = offset.x + 50, gameLevelTxt.y = canvasH / 100 * 48, gameLivesContainer.x = offset.x + 50, gameLivesContainer.y = canvasH / 100 * 52, gameCollectContainer.x = canvasW - offset.x - 50, gameCollectContainer.y = canvasH / 100 * 50) : (gameLevelTxt.textAlign = "right", gameScoreTxt.x = mapContainer.x, gameScoreTxt.y = mapContainer.y - 20, gameLevelTxt.x = gameScoreTxt.x + (a - gameData.squareSize) * mapContainer.scaleX, gameLevelTxt.y = gameScoreTxt.y, gameLivesContainer.x = gameScoreTxt.x, gameLivesContainer.y = mapContainer.y + (e - gameData.squareSize + 30) * mapContainer.scaleX, gameCollectContainer.x = gameLevelTxt.x - 25, gameCollectContainer.y = mapContainer.y + (e - gameData.squareSize + 30) * mapContainer.scaleX), gameControlContainer.x = canvasW / 2, gameControlContainer.y = canvasH / 100 * 85, "left" == mapSettings.mobileControl ? gameControlContainer.x = offset.x + 150 : "right" == mapSettings.mobileControl && (gameControlContainer.x = canvasW - offset.x - 150), mapMask.graphics.clear().beginFill("red").drawRect(-gameData.squareSize / 2, -gameData.squareSize / 2, a, e), mapWrapContainer.mask = mapMask, mapMultiPlayersContainer.mask = mapMask, mapMultiLabelsContainer.mask = mapMask, itemBroken.mask = mapMask, itemBroken.scaleY = 1, itemBroken.rotation = 0, itemBroken.x = 0, itemBroken.y = 0, "down" == gameData.mapLoopDirection ? itemBroken.y = e - 2 * gameData.squareSize : "up" == gameData.mapLoopDirection ? (itemBroken.y = gameData.squareSize, itemBroken.scaleY = -1) : "left" == gameData.mapLoopDirection ? (itemBroken.x = a - 2 * gameData.squareSize, itemBroken.y = e / 2, itemBroken.rotation = -90) : "right" == gameData.mapLoopDirection && (itemBroken.x = gameData.squareSize, itemBroken.y = e / 2, itemBroken.rotation = 90), viewport.isLandscape ? ($.players[0].x = offset.x + 50, $.players[0].y = canvasH / 100 * 25, $.players[1].x = canvasW - offset.x - 50, $.players[1].y = canvasH / 100 * 25, $.players[2].x = offset.x + 50, $.players[2].y = canvasH / 100 * 75, $.players[3].x = canvasW - offset.x - 50, $.players[3].y = canvasH / 100 * 75, 2 == gameData.users.length && ($.players[0].y = canvasH / 100 * 45, $.players[1].y = canvasH / 100 * 45)) : ($.players[0].x = mapContainer.x, $.players[0].y = mapContainer.y - 60, $.players[1].x = $.players[0].x + (a - gameData.squareSize) * mapContainer.scaleX, $.players[1].y = $.players[0].y, $.players[2].x = $.players[0].x, $.players[2].y = mapContainer.y + (e - gameData.squareSize + 30) * mapContainer.scaleX, $.players[3].x = $.players[2].x - 25, $.players[3].y = $.players[2].y + (e - gameData.squareSize + 30) * mapContainer.scaleX) } function insertMapBlock(a) { if ("down" == gameData.mapLoopDirection || "up" == gameData.mapLoopDirection) { var e = 0; a ? gameData.map.unshift([]) : (gameData.map.push([]), e = gameData.map.length - 1); for (var t = 0; t < maps_arr[gameData.mapNum].map[0].length; t++)gameData.map[e][t] = 0 } else for (var o = 0; o < gameData.map.length; o++)a ? gameData.map[o].unshift(0) : gameData.map[o].push(0) } function insertMapRow(a) { var e = 0; a ? gameData.map.unshift([]) : (gameData.map.push([]), e = gameData.map.length - 1); for (var t = [], o = 0; o < maps_arr[gameData.mapNum].map[gameData.replaceIndex].length; o++)gameData.map[e][o] = maps_arr[gameData.mapNum].map[gameData.replaceIndex][o], gameData.map[e][o] = gameData.map[e][o] == mapType.pill ? mapType.biscuit : gameData.map[e][o], gameData.map[e][o] == mapType.biscuit && t.push(o); gameData.pillTarget > mapSettings.loop.pillTarget && t.length > 0 && (shuffle(t), gameData.pillTarget = 0, gameData.map[e][t[0]] = mapType.pill), gameData.collectionTarget > mapSettings.loop.collectionTarget && t.length > 0 && (shuffle(t), gameData.collectionTarget = 0, gameData.map[e][t[0]] = insertCollection()), a ? (gameData.replaceIndex--, gameData.replaceIndex = gameData.replaceIndex < 0 ? maps_arr[gameData.mapNum].map.length - 1 : gameData.replaceIndex) : (gameData.replaceIndex++, gameData.replaceIndex = gameData.replaceIndex > maps_arr[gameData.mapNum].map.length - 1 ? 0 : gameData.replaceIndex) } function insertMapColumn(a) { for (var e = [], t = 0; t < gameData.map.length; t++) { var o = maps_arr[gameData.mapNum].map[t][gameData.replaceIndex]; o = o == mapType.pill ? mapType.biscuit : o, a ? gameData.map[t].unshift(o) : gameData.map[t].push(o), o == mapType.biscuit && e.push(t) } var n = e[0]; gameData.pillTarget > mapSettings.loop.pillTarget && e.length > 0 && (shuffle(e), n = e[0], gameData.pillTarget = 0, a ? gameData.map[n][0] = mapType.pill : gameData.map[n][gameData.map[n].length - 1] = mapType.pill), gameData.collectionTarget > mapSettings.loop.collectionTarget && e.length > 0 && (gameData.collectionTarget = 0, a ? gameData.map[n][0] = insertCollection() : gameData.map[n][gameData.map[n].length - 1] = insertCollection()), a ? (gameData.replaceIndex--, gameData.replaceIndex = gameData.replaceIndex < 0 ? maps_arr[gameData.mapNum].map[0].length - 1 : gameData.replaceIndex) : (gameData.replaceIndex++, gameData.replaceIndex = gameData.replaceIndex > maps_arr[gameData.mapNum].map[0].length - 1 ? 0 : gameData.replaceIndex) } function changeMapRow() { var a = 0; "down" == gameData.mapLoopDirection ? (gameData.map.splice(gameData.map.length - 2, 1), gameData.map.splice(0, 1), insertMapRow(!0), insertMapBlock(!0), a = 1, mapWrapContainer.y -= gameData.squareSize) : "up" == gameData.mapLoopDirection && (gameData.map.splice(1, 1), gameData.map.splice(gameData.map.length - 1, 1), insertMapRow(!1), insertMapBlock(!1), a = gameData.map.length - 2, mapWrapContainer.y += gameData.squareSize), resetLoopMap(0, a) } function changeMapColumn() { var a = 0; if ("left" == gameData.mapLoopDirection) { for (var e = 0; e < gameData.map.length; e++)gameData.map[e].splice(gameData.map[0].length - 2, 1); for (e = 0; e < gameData.map.length; e++)gameData.map[e].splice(0, 1); insertMapColumn(!0), insertMapBlock(!0), a = 1, mapWrapContainer.x -= gameData.squareSize } else if ("right" == gameData.mapLoopDirection) { for (e = 0; e < gameData.map.length; e++)gameData.map[e].splice(1, 1); for (e = 0; e < gameData.map.length; e++)gameData.map[e].splice(gameData.map[e].length - 1, 1); insertMapColumn(!1), insertMapBlock(!1), a = gameData.map[0].length - 2, mapWrapContainer.x += gameData.squareSize } resetLoopMap(a, 0) } function resetLoopMap(a, e) { drawWalls(), drawIcons(); var t = []; if ("down" == gameData.mapLoopDirection || "up" == gameData.mapLoopDirection) for (var o = 0; o < gameData.map[e].length; o++)gameData.map[e][o] == mapType.biscuit ? t.push({ x: o, y: e }) : gameData.map[e][o] == mapType.pill && t.push({ x: o, y: e }); else if ("left" == gameData.mapLoopDirection || "right" == gameData.mapLoopDirection) for (var n = 0; n < gameData.map.length; n++)gameData.map[n][a] == mapType.biscuit ? t.push({ x: a, y: n }) : gameData.map[n][a] == mapType.pill && t.push({ x: a, y: n }); for (var r = 0; r < gameData.users.length; r++) { var i = gameData.users[r]; if (i.active) { if ("down" == gameData.mapLoopDirection) { i.position.x = i.x, i.y += gameData.squareSize, i.position.y = i.y; e = pointToCoord(i.y); e >= gameData.mapH + gameData.mapLoopH - 1 && pacmanDie(i.index) } else if ("up" == gameData.mapLoopDirection) { i.position.x = i.x, i.y -= gameData.squareSize, i.position.y = i.y; e = pointToCoord(i.y); e <= 0 && pacmanDie(i.index) } else if ("left" == gameData.mapLoopDirection) { i.position.y = i.y, i.x += gameData.squareSize, i.position.x = i.x; a = pointToCoord(i.x); a >= gameData.mapW + gameData.mapLoopW - 1 && pacmanDie(i.index) } else if ("right" == gameData.mapLoopDirection) { i.position.y = i.y, i.x -= gameData.squareSize, i.position.x = i.x; a = pointToCoord(i.x); a <= 0 && pacmanDie(i.index) } updateLabel(i) } } for (r = 0; r < gameData.ghosts.length; r++) { var m = gameData.ghosts[r]; if ("down" == gameData.mapLoopDirection) { m.y += gameData.squareSize, m.position.y = m.y; e = pointToCoord(m.y); e >= gameData.mapH + gameData.mapLoopH - 1 && (m.active = !1) } else if ("up" == gameData.mapLoopDirection) { m.y -= gameData.squareSize, m.position.y = m.y; e = pointToCoord(m.y); e <= 0 && (m.active = !1) } else if ("left" == gameData.mapLoopDirection) { m.x += gameData.squareSize, m.position.x = m.x; a = pointToCoord(m.x); a >= gameData.mapW + gameData.mapLoopW - 1 && (m.active = !1) } else { m.x -= gameData.squareSize, m.position.x = m.x; a = pointToCoord(m.x); a <= 0 && (m.active = !1) } m.active || t.length > 0 && (shuffle(t), m.x = t[0].x * gameData.squareSize, m.y = t[0].y * gameData.squareSize, m.position.x = m.x, m.position.y = m.y, m.active = !0), m.chaseUser && m.followPath && chaseUser(m) } } function startCountdown(a) { gameData.countdown = 0, playSound("soundStart"), showGameStatus(a ? "ready" : "level"), "function" == typeof initSocket && multiplayerSettings.enable && socketData.online ? socketData.host && loopCountdown() : loopCountdown() } function loopCountdown() { var a = .001 * mapSettings.countdownTimer; TweenMax.to(gameStatusTxt, a, { overwrite: !0, onComplete: function () { "function" == typeof initSocket && multiplayerSettings.enable && socketData.online ? socketData.host && postSocketUpdate("loopcountdowncomplete", gameData.countdown) : loopCountdownComplete() } }) } function loopCountdownComplete() { showGameStatus("countdown"), gameData.countdown++, gameData.countdown > textDisplay.gameCountdown.length ? (toggleGameSound("normal"), showGameStatus(""), gameData.paused = !1, toggleGameTimer(!0)) : (playSound("soundCountdown"), "function" == typeof initSocket && multiplayerSettings.enable && socketData.online ? socketData.host && loopCountdown() : loopCountdown()) } function toggleGameSound(a) { stopMusicLoop("soundLoop"), stopMusicLoop("soundSiren"), stopMusicLoop("soundSiren2"), "normal" == a ? playMusicLoop("soundLoop") : "pill" == a ? playMusicLoop("soundSiren") : "eaten" == a && playMusicLoop("soundSiren2") } function showGameStatus(a) { gameStatusTxt.text = "ready" == a ? textDisplay.gameReady : "level" == a ? textDisplay.gameReadyLevel.replace("[NUMBER]", gameData.level + 1) : "clear" == a ? textDisplay.gameClear : "over" == a ? textDisplay.gameOver : "countdown" == a ? textDisplay.gameCountdown[gameData.countdown] : "" } function getTargetPath(a) { if (-1 != isMap(a.targetPath[0], a.targetPath[1])) { var e = new EasyStar.js; e.setGrid(gameData.map), e.setAcceptableTiles([mapType.empty, mapType.biscuit, mapType.pill, mapType.block, mapType.gateHorizontal, mapType.gateVertical, mapType.collection[0], mapType.collection[1], mapType.collection[2], mapType.collection[3], mapType.collection[4], mapType.collection[5], mapType.collection[6], mapType.collection[7], mapType.collection[8], mapType.collection[9]]), e.findPath(pointToCoord(a.x), pointToCoord(a.y), a.targetPath[0], a.targetPath[1], function (e) { null != e && e.length > 0 ? (a.pathIndex = 0, a.pathArray = e) : (a.followPath = !1, a.followPathType = "") }), e.calculate() } else a.followPath = !1, a.followPathType = "" } function drawWalls() { mapDrawContainer.removeAllChildren(); for (var a = 0; a < gameData.map.length; a++)for (var e = 0; e < gameData.map[a].length; e++)if (-1 != mapType.walls.indexOf(gameData.map[a][e]) || gameData.map[a][e] == mapType.block || gameData.map[a][e] == mapType.gateHorizontal || gameData.map[a][e] == mapType.gateVertical) { var t = drawWallType(gameData.map[a][e]); t.x = e * gameData.squareSize, t.y = a * gameData.squareSize, mapDrawContainer.addChild(t) } } function drawWallType(a) { var e; return 4 == a ? e = drawWallShape("block") : 5 == a || 6 == a ? (e = drawWallShape("gate"), 6 == a && (e.rotation = 90)) : 10 == a || 11 == a ? (e = drawWallShape("line"), e.rotation = 11 == a ? 90 : 0) : 12 == a || 13 == a || 14 == a || 15 == a ? (e = drawWallShape("corner"), 13 == a ? e.rotation = 90 : 14 == a ? e.rotation = 180 : 15 == a && (e.rotation = 270)) : 16 == a || 17 == a || 18 == a || 19 == a ? (e = drawWallShape("tjunc"), 17 == a ? e.rotation = 90 : 18 == a ? e.rotation = 180 : 19 == a && (e.rotation = 270)) : 20 == a ? e = drawWallShape("cross") : 30 == a || 31 == a ? (e = drawWallShape("doubleline"), e.rotation = 31 == a ? 90 : 0) : 32 == a || 33 == a || 34 == a || 35 == a ? (e = drawWallShape("doublecorner"), 33 == a ? e.rotation = 90 : 34 == a ? e.rotation = 180 : 35 == a && (e.rotation = 270)) : 36 == a || 37 == a || 38 == a || 39 == a ? (e = drawWallShape("doubletjunc"), 37 == a ? e.rotation = 90 : 38 == a ? e.rotation = 180 : 39 == a && (e.rotation = 270)) : 40 == a || 41 == a || 42 == a || 43 == a ? (e = drawWallShape("doubletjunctobold"), 41 == a ? e.rotation = 90 : 42 == a ? e.rotation = 180 : 43 == a && (e.rotation = 270)) : 44 == a || 45 == a || 46 == a || 47 == a ? (e = drawWallShape("doubleend"), 45 == a ? e.rotation = 90 : 46 == a ? e.rotation = 180 : 47 == a && (e.rotation = 270)) : 48 == a ? e = drawWallShape("doublecross") : 60 == a || 61 == a ? (e = drawWallShape("doubleboldline"), e.rotation = 61 == a ? 90 : 0) : 62 == a || 63 == a || 64 == a || 65 == a ? (e = drawWallShape("doubleboldcorner"), 63 == a ? e.rotation = 90 : 64 == a ? e.rotation = 180 : 65 == a && (e.rotation = 270)) : 66 == a || 67 == a || 68 == a || 69 == a ? (e = drawWallShape("doubleboldtjunc"), 67 == a ? e.rotation = 90 : 68 == a ? e.rotation = 180 : 69 == a && (e.rotation = 270)) : 70 == a || 71 == a || 72 == a || 73 == a ? (e = drawWallShape("doubleboldtjunctonormal"), 71 == a ? e.rotation = 90 : 72 == a ? e.rotation = 180 : 73 == a && (e.rotation = 270)) : 74 == a || 75 == a || 76 == a || 77 == a ? (e = drawWallShape("doubleboldend"), 75 == a ? e.rotation = 90 : 76 == a ? e.rotation = 180 : 77 == a && (e.rotation = 270)) : 78 == a ? e = drawWallShape("doubleboldcross") : 80 == a ? e = drawWallShape("circle") : 90 == a || 91 == a ? (e = drawWallShape("gate"), 91 == a && (e.rotation = 90)) : e = drawWallShape("empty"), e } function drawWallShape(a) { gameData.strokeColor = "#fff"; var e = new createjs.Shape; setWallStroke(e); var t = gameData.squareSize / 2 + 1, o = t / 3, n = t / 2; return "line" == a ? e.graphics.mt(-t, 0).lt(t, 0) : "corner" == a ? e.graphics.mt(-t, 0).qt(0, 0, 0, t) : "tjunc" == a ? (e.graphics.mt(-t, 0).lt(t, 0).es(), setWallStroke(e), e.graphics.mt(0, 0).lt(0, t).es()) : "cross" == a ? (e.graphics.mt(-t, 0).lt(t, 0), setWallStroke(e), e.graphics.mt(0, -t).lt(0, t)) : "doubleline" == a ? (e.graphics.mt(-t, -o).lt(t, -o).es(), setWallStroke(e), e.graphics.mt(-t, o).lt(t, o).es()) : "doublecorner" == a ? (e.graphics.mt(-t, -o).qt(o, -o, o, t).es(), setWallStroke(e), e.graphics.mt(-t, o).qt(-o, o, -o, t).es()) : "doubletjunc" == a ? (e.graphics.mt(-t, -o).lt(t, -o).es(), setWallStroke(e), e.graphics.mt(-t, o).lt(-o, o).lt(-o, t).es(), setWallStroke(e), e.graphics.mt(t, o).lt(o, o).lt(o, t).es()) : "doubletjunctobold" == a ? (e.graphics.mt(-t, -o).lt(t, -o).es(), setWallStroke(e), e.graphics.mt(-t, o).lt(-n, o).lt(-n, t).es(), setWallStroke(e), e.graphics.mt(t, o).lt(n, o).lt(n, t).es()) : "doubleend" == a ? (e.graphics.mt(-t, -o).lt(0, -o).qt(o, -o, o, 0).es(), setWallStroke(e), e.graphics.mt(-t, o).lt(0, o).qt(o, o, o, 0).es()) : "doublecross" == a ? (e.graphics.mt(-t, -o).lt(-o, -o).lt(-o, -t).es(), setWallStroke(e), e.graphics.mt(o, -t).lt(o, -o).lt(t, -o).es(), setWallStroke(e), e.graphics.mt(t, o).lt(o, o).lt(o, t).es(), setWallStroke(e), e.graphics.mt(-t, o).lt(-o, o).lt(-o, t).es()) : "doubleboldline" == a ? (e.graphics.mt(-t, -n).lt(t, -n).es(), setWallStroke(e), e.graphics.mt(-t, n).lt(t, n).es()) : "doubleboldcorner" == a ? (e.graphics.mt(-t, -n).qt(n, -n, n, t).es(), setWallStroke(e), e.graphics.mt(-t, n).qt(-n, n, -n, t).es()) : "doubleboldtjunc" == a ? (e.graphics.mt(-t, -n).lt(t, -n).es(), setWallStroke(e), e.graphics.mt(-t, n).lt(-n, n).lt(-n, t).es(), setWallStroke(e), e.graphics.mt(t, n).lt(n, n).lt(n, t).es()) : "doubleboldtjunctonormal" == a ? (e.graphics.mt(-t, -n).lt(t, -n).es(), setWallStroke(e), e.graphics.mt(-t, n).lt(-o, n).lt(-o, t).es(), setWallStroke(e), e.graphics.mt(t, n).lt(o, n).lt(o, t).es()) : "doubleboldend" == a ? (e.graphics.mt(-t, -n).lt(0, -n).qt(n, -n, n, 0).es(), setWallStroke(e), e.graphics.mt(-t, n).lt(0, n).qt(n, n, n, 0).es()) : "doubleboldcross" == a ? (e.graphics.mt(-t, -n).lt(-n, -n).lt(-n, -t).es(), setWallStroke(e), e.graphics.mt(n, -t).lt(n, -n).lt(t, -n).es(), setWallStroke(e), e.graphics.mt(t, n).lt(n, n).lt(n, t).es(), setWallStroke(e), e.graphics.mt(-t, n).lt(-n, n).lt(-n, t).es()) : "circle" == a ? e.graphics.drawCircle(0, 0, t / 2) : "block" == a ? $.editor.enable && (editData.testPlay || (e.graphics.beginFill("#00468C").drawRect(-gameData.squareSize / 2, -gameData.squareSize / 2, gameData.squareSize, gameData.squareSize), e.alpha = .8)) : "gate" == a && (e.graphics.setStrokeStyle(mapSettings.design.strokeNum).beginStroke(theme_settings[gameData.themeNum].gateColor), e.graphics.mt(-t, 0).lt(t, 0)), e } function setWallStroke(a) { a.graphics.setStrokeStyle(mapSettings.design.strokeNum).beginStroke(theme_settings[gameData.themeNum].strokeColor) } function drawIcons() { mapIconsContainer.removeAllChildren(), insertMapIcons(gameData.map, 1); for (var a = 0; a < multiData.players.length; a++)a != gameData.gameIndex && null != multiData.players[a].map && socketData.players[a].lives > 0 && insertMapIcons(multiData.players[a].map, multiData.alpha) } function insertMapIcons(a, e) { for (var t = 0; t < a.length; t++)for (var o = 0; o < a[t].length; o++)if (a[t][o] == mapType.biscuit) { var n = new createjs.Shape; n.graphics.beginFill(theme_settings[gameData.themeNum].biscuitColor).drawCircle(0, 0, mapSettings.biscuitSize), n.x = gameData.squareSize * o, n.y = gameData.squareSize * t, n.alpha = e, mapIconsContainer.addChild(n) } else if (a[t][o] == mapType.pill) { var r = new createjs.Shape; r.graphics.beginFill(theme_settings[gameData.themeNum].pillColor).drawCircle(0, 0, mapSettings.pillSize), r.x = gameData.squareSize * o, r.y = gameData.squareSize * t, r.alpha = e, mapIconsContainer.addChild(r) } else if (-1 != mapType.collection.indexOf(a[t][o])) { var i = Number(String(a[t][o]).substring(2, 3)), m = new createjs.Bitmap(loader.getResult("collection_" + gameData.themeNum + "_" + i)); centerReg(m), m.x = gameData.squareSize * o, m.y = gameData.squareSize * t, m.alpha = e, mapIconsContainer.addChild(m) } } function insertCollection() { if (theme_settings[gameData.themeNum].collection.length > 0) { var a = !1; if (gameData.mapLoop) { var e = Math.floor(Math.random() * theme_settings[gameData.themeNum].collection.length); return mapType.collection[e] } if (gameData.pathArray.length > 0) { for (var t = gameData.pathArrayIndex; t < gameData.pathArray.length; t++) { var o = gameData.pathArray[t].x, n = gameData.pathArray[t].y; if (gameData.map[n][o] == mapType.empty) { e = Math.floor(Math.random() * theme_settings[gameData.themeNum].collection.length); gameData.map[n][o] = mapType.collection[e], t = gameData.pathArray.length, gameData.pathArrayIndex++ } } gameData.pathArrayIndex++, gameData.pathArrayIndex = gameData.pathArrayIndex > gameData.pathArray.length - 1 ? 0 : gameData.pathArrayIndex, drawIcons() } if (a) { e = Math.floor(Math.random() * theme_settings[gameData.themeNum].collection.length); var r = new createjs.Bitmap(loader.getResult("collection_" + gameData.themeNum + "_" + e)); centerReg(r), r.collectType = e, mapCollectContainer.addChild(r), gameData.mapLoop ? (r.column = x, r.row = y, r.x = x * gameData.squareSize, r.y = y * gameData.squareSize) : (r.x = gameData.pathArray[gameData.pathArrayIndex].x * gameData.squareSize, r.y = gameData.pathArray[gameData.pathArrayIndex].y * gameData.squareSize, gameData.pathArrayIndex++, gameData.pathArrayIndex = gameData.pathArrayIndex > gameData.pathArray.length - 1 ? 0 : gameData.pathArrayIndex) } } } function createPacman(a) {
    var e = .5, t = 24, o = 24, n = { regX: t / 2, regY: o / 2, height: o, width: t, count: 10 }, r = { start: { frames: [0], speed: e }, eat: { frames: [1, 2, 3], speed: e }, stay: { frames: [3], speed: e }, die: { frames: [4, 5, 6, 7, 8, 9], speed: e, next: "diestill" }, diestill: { frames: [9], speed: e } }; userData = new createjs.SpriteSheet({ images: [loader.getResult("user_" + gameData.themeNum + "_" + a).src], frames: n, animations: r }); var i = new createjs.Sprite(userData, "start"); i.framerate = 20, i.spriteDirection = "start"; var m = new createjs.Text; "function" == typeof initSocket && multiplayerSettings.enable && socketData.online && (m.font = "25px upheaval_tt_brkregular", m.color = "#fff", m.textAlign = "center", m.textBaseline = "alphabetic", m.text = textDisplay.multiplayerIndicator.replace("[NUMBER]", gameData.users.length + 1)), i.nameLabel = m, gameData.users.push(i), gameData.gameIndex == gameData.users.length - 1 ? (mapPlayersContainer.addChild(i),
        mapLabelsContainer.addChild(m)) : (mapMultiPlayersContainer.addChild(i), mapMultiLabelsContainer.addChild(m))
} function createGhosts() { gameData.ghosts = []; for (var a = 0, e = 0; e < maps_arr[gameData.mapNum].totalGhosts.length; e++) { var t = .2, o = 24, n = 24, r = { regX: o / 2, regY: n / 2, height: n, width: o, count: 40 }, i = { right: { frames: [0, 1], speed: t }, left: { frames: [2, 3], speed: t }, up: { frames: [4, 5], speed: t }, down: { frames: [6, 7], speed: t }, stay: { frames: [8, 9], speed: t }, blueright: { frames: [10, 11], speed: t }, blueleft: { frames: [12, 13], speed: t }, blueup: { frames: [14, 15], speed: t }, bluedown: { frames: [16, 17], speed: t }, bluestay: { frames: [18, 19], speed: t }, whiteright: { frames: [20, 21], speed: t }, whiteleft: { frames: [22, 23], speed: t }, whiteup: { frames: [24, 25], speed: t }, whitedown: { frames: [26, 27], speed: t }, whitestay: { frames: [28, 29], speed: t }, blackright: { frames: [30, 31], speed: t }, blackleft: { frames: [32, 33], speed: t }, blackup: { frames: [34, 35], speed: t }, blackdown: { frames: [36, 37], speed: t }, blackstay: { frames: [38, 39], speed: t } }; ghostData = new createjs.SpriteSheet({ images: [loader.getResult("ghost_" + gameData.themeNum + "_" + a).src], frames: r, animations: i }), newGhost = new createjs.Sprite(ghostData, "stay"), newGhost.framerate = 20, mapPlayersContainer.addChild(newGhost), gameData.ghosts.push(newGhost), a++, a = a > theme_settings[gameData.themeNum].ghosts.length - 1 ? 0 : a } if ("function" == typeof initSocket && multiplayerSettings.enable && socketData.online) for (var m = 0; m < socketData.players.length; m++)if (multiData.players.push({ map: null, ghosts: [] }), m != gameData.gameIndex) for (e = 0; e < gameData.ghosts.length; e++) { var l = gameData.ghosts[e].clone(!0); l.alpha = 0, multiData.players[m].ghosts.push(l), mapMultiPlayersContainer.addChild(l) } } function resetPacman(a) { "function" == typeof initSocket && multiplayerSettings.enable && socketData.online ? (gameData.users[a].x = (gameData.multiPos[gameData.multiPosIndex][0] + gameData.mapExtraX) * gameData.squareSize, gameData.users[a].y = (gameData.multiPos[gameData.multiPosIndex][1] + gameData.mapExtraY) * gameData.squareSize, gameData.users[a].direction = maps_arr[gameData.mapNum].multiDirection[gameData.multiPosIndex], gameData.users[a].due = maps_arr[gameData.mapNum].multiDirection[gameData.multiPosIndex], a != gameData.gameIndex && (gameData.users[a].x += mapWrapContainer.x, gameData.users[a].y += mapWrapContainer.y), gameData.multiPosIndex++, gameData.multiPosIndex = gameData.multiPosIndex > gameData.multiPos.length - 1 ? 0 : gameData.multiPosIndex) : (gameData.users[a].x = (gameData.startPos[0] + gameData.mapExtraX) * gameData.squareSize, gameData.users[a].y = (gameData.startPos[1] + gameData.mapExtraY) * gameData.squareSize, gameData.users[a].direction = maps_arr[gameData.mapNum].startDirection, gameData.users[a].due = maps_arr[gameData.mapNum].startDirection), gameData.users[a].active = !0, gameData.users[a].invisible = !1, gameData.users[a].alpha = 1, gameData.users[a].index = a, gameData.users[a].position = { x: gameData.users[a].x, y: gameData.users[a].y }, gameData.users[a].lastposition = { x: gameData.users[a].x, y: gameData.users[a].y }, gameData.users[a].spriteDirection = "start", gameData.users[a].gotoAndPlay("start"), updateLabel(gameData.users[a]) } function resetGhosts() { gameData.ghostStayPosIndex = 0, gameData.mapLoop && shuffle(gameData.ghostStayPos); for (var a = 0; a < gameData.ghosts.length; a++) { var e = gameData.ghosts[a]; e.active = !1, e.status = "stay", e.index = a, e.x = (gameData.ghostStayPos[gameData.ghostStayPosIndex][0] + gameData.mapExtraX) * gameData.squareSize, e.y = (gameData.ghostStayPos[gameData.ghostStayPosIndex][1] + gameData.mapExtraY) * gameData.squareSize, gameData.ghostStayPosIndex++, gameData.ghostStayPosIndex = gameData.ghostStayPosIndex > gameData.ghostStayPos.length - 1 ? 0 : gameData.ghostStayPosIndex, gameData.mapLoop && (e.active = !0, e.status = "move"), e.followPath = !1, e.followPathType = "", e.followPlayer = null, e.targetPath = [-1, -1], e.position = { x: e.x, y: e.y }, e.direction = getRandomDirection(e), e.due = getRandomDirection(e), e.pathArray = [], e.pathIndex = 0, e.recover = !1, e.ghostDate = new Date, e.chaseUser = randomBoolean(), e.spriteDirection = "stay", e.gotoAndPlay("stay"), e.tryArr = [], e.tryIndex = 0, TweenMax.killTweensOf(e) } } function getRandomDirection(a) { var e = "left" === a.direction || "right" === a.direction ? ["up", "down"] : ["left", "right"]; return e[Math.floor(2 * Math.random())] } function setPacmanDirection(a, e) { gameData.users[a].due = e } function checkControl() { var a = ""; toggleTouchArrow("up", !1), toggleTouchArrow("down", !1), toggleTouchArrow("left", !1), toggleTouchArrow("right", !1), gameData.moveControl.left && (a = "left"), gameData.moveControl.right && (a = "right"), gameData.moveControl.up && (a = "up"), gameData.moveControl.down && (a = "down"), "" != a && (toggleTouchArrow(a, !0), setPacmanDirection(gameData.gameIndex, a)) } function movePacman(a) { if (!a.active) return a.position; var e = null, t = null, o = null; if (a.due !== a.direction && (e = getNewCoord(a.due, a.position), isOnSamePlane(a.due, a.direction) || onGridSquare(a.position) && isFloorSpace(getSquare(e, a.due)) ? a.direction = a.due : e = null), null === e && (e = getNewCoord(a.direction, a.position)), onGridSquare(a.position) && isWall(getSquare(e, a.direction)) && (a.direction = ""), "" === a.direction) return a.position; var n = pane(e, a); if (n && (e = n), a.position = e, t = getPacman(a.position, a.direction), isMap(t.x, t.y) && (o = getBlock(t), !a.invisible)) if (o === mapType.biscuit || o === mapType.pill) { if (setBlock(t, mapType.empty), drawIcons(), addScore(o === mapType.biscuit ? mapSettings.score.biscuit : mapSettings.score.pill, a.index), gameData.eaten += 1, gameData.eaten === gameData.totalEaten && showGameStage("clear"), o === mapType.biscuit) playSound("soundEat"); else if (o === mapType.pill) { toggleGameSound("pill"), playSound("soundEatPill"), togglePillTimer(!0); for (var r = 0; r < gameData.ghosts.length; r++) { var i = gameData.ghosts[r]; "hidden" != i.status && changeGhostType(i, "eatable") } } } else if (-1 != mapType.collection.indexOf(o)) { playSound("soundCollect"), setBlock(t, mapType.empty), drawIcons(); var m = mapType.collection.indexOf(o); gameData.collected.push(m), addScore(mapSettings.score.collection, a.index) } return a.position } function moveGhosts(a) { if (!a.active) return a.position; var e = onGridSquare(a.position), t = null; if (a.followPath) { if (a.pathArray.length > 0 && a.pathIndex < a.pathArray.length) { var o = pointToCoord(a.x), n = pointToCoord(a.y), r = a.pathArray[a.pathIndex].x, i = a.pathArray[a.pathIndex].y; return o < r ? a.direction = "right" : o > r ? a.direction = "left" : n < i ? a.direction = "down" : n > i && (a.direction = "up"), o == r && n == i && e ? (t = a.position, t.x = r * gameData.squareSize, t.y = i * gameData.squareSize, a.pathIndex++, a.pathIndex >= a.pathArray.length && (a.followPath = !1, a.followPathType = "", "hidden" != a.status || gameData.mapLoop || (a.recover = !0, changeGhostType(a, "move"), releaseGhost(a)))) : t = getGhostNewCoord(a.direction, a), a.position = t, t } return a.position } if (a.due !== a.direction && (t = getGhostNewCoord(a.due, a), e && isFloorSpace({ y: pointToCoord(nextSquare(t.y, a.due)), x: pointToCoord(nextSquare(t.x, a.due)) }) ? a.direction = a.due : t = null), null === t && (t = getGhostNewCoord(a.direction, a)), e && isWall({ y: pointToCoord(nextSquare(t.y, a.direction)), x: pointToCoord(nextSquare(t.x, a.direction)) })) { if (0 == a.tryArr.length) { a.tryArr = [], a.tryIndex = 0; for (var m = ["left", "right", "up", "down"], l = 0; l < m.length; l++)isWall({ y: pointToCoord(nextSquare(t.y, m[l])), x: pointToCoord(nextSquare(t.x, m[l])) }) || a.tryArr.push(m[l]); shuffle(a.tryArr) } return a.tryArr.length > 0 && a.tryIndex < a.tryArr.length ? (a.due = a.tryArr[a.tryIndex], a.tryIndex++, moveGhosts(a)) : (a.due = getRandomDirection(a), a.position) } a.tryArr.length = 0, a.position = t; var s = pane(t, a); return s && (a.position = s), a.due = getRandomDirection(a), a.position } function pane(a, e) { var t = !0, o = !0; if (gameData.mapLoop && ("left" != gameData.mapLoopDirection && "right" != gameData.mapLoopDirection || (t = !1), "up" != gameData.mapLoopDirection && "down" != gameData.mapLoopDirection || (o = !1)), t) { if (a.x >= gameData.mapW * gameData.squareSize && "right" === e.direction) return { y: e.position.y, x: -gameData.squareSize }; if (a.x <= -(gameData.squareSize + 2) && "left" === e.direction) return { y: e.position.y, x: gameData.mapW * gameData.squareSize } } if (o) { if (a.y >= gameData.mapH * gameData.squareSize && "down" === e.direction) return { y: -gameData.squareSize, x: e.position.x }; if (a.y <= -(gameData.squareSize + 2) && "up" === e.direction) return { y: gameData.mapH * gameData.squareSize, x: e.position.x } } return !1 } function releaseGhost(a) { a.active = !0, a.followPath = !0, a.followPathType = "enter", a.recover ? a.status = "move" : a.status = 1 == timeData.pillEnable ? "eatable" : "move", a.targetPath = [gameData.ghostPos[0], gameData.ghostPos[1]], getTargetPath(a) } function chaseUser(a) { a.followPath = !0, a.followPathType = "user", a.targetPath = [pointToCoord(a.followPlayer.x), pointToCoord(a.followPlayer.y)], getTargetPath(a) } function getNewCoord(a, e) { return { x: e.x + ("left" === a && -gameData.userSpeed || "right" === a && gameData.userSpeed || 0), y: e.y + ("down" === a && gameData.userSpeed || "up" === a && -gameData.userSpeed || 0) } } function onGridSquare(a) { return onWholeSquare(a.y) && onWholeSquare(a.x) } function onWholeSquare(a) { return a % gameData.squareSize == 0 } function pointToCoord(a) { return Math.round(a / gameData.squareSize) } function nextSquare(a, e) { var t = a % gameData.squareSize; return 0 === t ? a : "right" === e || "down" === e ? a + (gameData.squareSize - t) : a - t } function nextPacman(a, e) { var t = a % gameData.monsterSize; return 0 === t ? a : "right" === e || "down" === e ? a + (gameData.monsterSize - t) : a - t } function isOnSamePlane(a, e) { return !(("left" !== a && "right" !== a || "left" !== e && "right" !== e) && ("up" !== a && "down" !== a || "up" !== e && "down" !== e)) } function withinBounds(a, e) { return a >= 0 && a < gameData.mapH + gameData.mapLoopH && e >= 0 && e < gameData.mapW + gameData.mapLoopW } function isWall(a) { var e = !1; return withinBounds(a.y, a.x) && (-1 != mapType.walls.indexOf(isMap(a.x, a.y)) && (e = !0), isMap(a.x, a.y) != mapType.gateHorizontal && isMap(a.x, a.y) != mapType.gateVertical || (e = !0), isMap(a.x, a.y) == mapType.block && (e = !0)), e } function isMap(a, e) { return null != gameData.map[e] && null != gameData.map[e][a] ? gameData.map[e][a] : -1 } function isFloorSpace(a) { if (!withinBounds(a.y, a.x)) return !1; var e = isMap(a.x, a.y); return e === mapType.empty || e === mapType.biscuit || e === mapType.pill || -1 != mapType.collection.indexOf(e) } function getSquare(a, e) { return { y: pointToCoord(nextSquare(a.y, e)), x: pointToCoord(nextSquare(a.x, e)) } } function getPacman(a, e) { return { y: pointToCoord(nextPacman(a.y, e)), x: pointToCoord(nextPacman(a.x, e)) } } function getBlock(a) { return gameData.map[a.y][a.x] } function setBlock(a, e) { gameData.map[a.y][a.x] = e } function getGhostNewCoord(a, e) { var t = "move" == e.status ? gameData.ghostSpeed : "hidden" == e.status ? gameData.ghostEatenSpeed : gameData.ghostEatableSpeed, o = "left" === a && -t || "right" === a && t || 0, n = "down" === a && t || "up" === a && -t || 0; return { x: addBounded(e.x, o), y: addBounded(e.y, n) } } function addBounded(a, e) { var t = a % gameData.squareSize, o = t + e; return 0 !== t && o > gameData.squareSize ? a + (gameData.squareSize - t) : t > 0 && o < 0 ? a - t : a + e } function oppositeDirection(a) { return ("left" === a ? "right" : "right" === a && "left") || "up" === a && "down" || "up" } function addScore(a, e) { if (playerData.score += a, "function" == typeof initSocket && multiplayerSettings.enable && socketData.online) { var t = socketData.players.findIndex(a => a.gameIndex === e); socketData.players[t].score += a, postSocketUpdate("updatestats", { index: e, score: socketData.players[t].score, lives: socketData.players[t].lives }, !0) } else playerData.score += a; updateGameDisplay() } function updateGameDisplay() { gameLivesContainer.removeAllChildren(), gameCollectContainer.removeAllChildren(), gameScoreTxt.text = "", gameLevelTxt.text = ""; for (var a = 0; a < 4; a++)$.players[a].visible = !1; if ("function" == typeof initSocket && multiplayerSettings.enable && socketData.online) { for (a = 0; a < 4; a++)if (a < socketData.players.length) { $.players[a].visible = !0, $.players["name" + a].text = textDisplay.multiplayerName.replace("[NUMBER]", a + 1) + socketData.players[a].username, $.players["score" + a].text = textDisplay.gameScore.replace("[NUMBER]", addCommas(socketData.players[a].score)), $.players["icons" + a].removeAllChildren(); var e = gameData.squareSize / 2; isEven(a) || (e = -e), spaceX = 1.3 * gameData.squareSize; for (var t = 0; t < socketData.players[a].lives; t++) { var o = gameData.users[a].clone(); o.gotoAndPlay("stay"), o.x = e, o.y = 0, o.scaleX = 1, o.rotation = 0, o.alpha = 1, isEven(a) ? e += spaceX : e -= spaceX, $.players["icons" + a].addChild(o) } } } else { gameScoreTxt.text = textDisplay.gameScore.replace("[NUMBER]", addCommas(playerData.score)), gameLevelTxt.text = textDisplay.gameLevel.replace("[NUMBER]", gameData.level + 1); e = gameData.squareSize / 2; spaceX = 1.3 * gameData.squareSize; for (a = 0; a < gameData.lives; a++)$.objects[a] = gameData.users[gameData.gameIndex].clone(), $.objects[a].gotoAndPlay("stay"), $.objects[a].x = e, $.objects[a].y = 0, $.objects[a].scaleX = 1, $.objects[a].rotation = 0, $.objects[a].alpha = 1, e += spaceX, gameLivesContainer.addChild($.objects[a]); e = gameData.squareSize / 2; spaceX = 1.3 * gameData.squareSize; for (a = 0; a < gameData.collected.length; a++) { var n = new createjs.Bitmap(loader.getResult("collection_" + gameData.themeNum + "_" + gameData.collected[a])); centerReg(n), n.x = e, e -= spaceX, gameCollectContainer.addChild(n) } } } function showGameStage(a) { var e = 2; if ("clear" == a) if (gameData.mapLoop) { if (gameData.users[gameData.gameIndex].active) { gameData.paused = !0, toggleGameTimer(!1), gameData.level++, getLevelSettings(), updateGameDisplay(); var t = gameData.users[gameData.gameIndex], o = pointToCoord(t.x), n = pointToCoord(t.y); t.x = o * gameData.squareSize, t.y = n * gameData.squareSize, playSound("soundLevel"), showGameStatus("level"), gameData.users[gameData.gameIndex].spriteDirection = "stay", gameData.users[gameData.gameIndex].gotoAndPlay("stay"), TweenMax.to(gameStatusTxt, e, { overwrite: !0, onComplete: function () { showGameStatus(""), gameData.paused = !1, toggleGameTimer(!0) } }) } } else gameData.users[gameData.gameIndex].active && (stopGame(), playSound("soundLevel"), showGameStatus("clear"), gameData.users[gameData.gameIndex].gotoAndPlay("stay"), TweenMax.to(gameStatusTxt, e, { overwrite: !0, onComplete: function () { gameData.level++, updateGameDisplay(), prepareGame(), startCountdown(!1) } })); else "ready" == a && (resetTimer(), resetGhosts(), resetPacman(gameData.gameIndex), showGameStatus("ready"), TweenMax.to(gameStatusTxt, e, { overwrite: !0, onComplete: function () { togglePillTimer(!1), showGameStatus(""), gameData.paused = !1, toggleGameTimer(!0) } })) } function toggleGameTimer(a) { a ? (timeData.startDate = new Date, gameData.releaseIndex = 0, resetCollectTimer()) : (timeData.accumulate = timeData.timer, timeData.accumulatePill = 0, timeData.pillEnable && (timeData.accumulatePill = timeData.pillTimer)), timeData.enable = a } function togglePillTimer(a) { if (a) timeData.oldTimer = -1, timeData.countdown = mapSettings.pillTimer, gameData.ghostBlink = !1, timeData.pillDate = new Date; else { for (var e = 0; e < gameData.ghosts.length; e++) { var t = gameData.ghosts[e]; 1 == t.active && (t.followPath = !1, t.followPathType = "", changeGhostType(t, "move")) } toggleGameSound("normal") } timeData.pillEnable = a } function resetTimer() { timeData.accumulate = 0, timeData.accumulatePill = 0 } function resetCollectTimer() { timeData.collectDate = new Date } function updateGame() { if (!gameData.paused) { if (timeData.enable && (timeData.nowDate = new Date, timeData.elapsedTime = Math.floor(timeData.nowDate.getTime() - timeData.startDate.getTime()), timeData.timer = timeData.elapsedTime + timeData.accumulate, timeData.timer > gameData.totalGhosts[gameData.releaseIndex] && gameData.releaseIndex < gameData.totalGhosts.length && !gameData.mapLoop && (releaseGhost(gameData.ghosts[gameData.releaseIndex]), gameData.releaseIndex++), gameData.mapLoop || (timeData.collecTimer = Math.floor(timeData.nowDate.getTime() - timeData.collectDate.getTime()), timeData.collecTimer = timeData.collecTimer, timeData.collecTimer > mapSettings.collectShowTimer && (resetCollectTimer(), insertCollection())), timeData.pillEnable)) if (timeData.elapsedTime = Math.floor(timeData.nowDate.getTime() - timeData.pillDate.getTime()), timeData.pillTimer = Math.floor(timeData.countdown - timeData.elapsedTime), -1 == timeData.oldTimer && (timeData.oldTimer = timeData.pillTimer), timeData.pillTimer <= 0) togglePillTimer(!1); else if (timeData.oldTimer - timeData.pillTimer > mapSettings.ghostBlinkTimer) { if (timeData.pillTimer < 5e3 && (gameData.ghostBlink || (gameData.ghostBlink = !0, gameData.ghostBlinkSide = !0), gameData.ghostBlink)) { for (var a = 0; a < gameData.ghosts.length; a++) { var e = gameData.ghosts[a]; if ("eatable" != e.status || e.recover) { if ("hidden" == e.status) { var t = Math.floor(timeData.nowDate.getTime() - e.ghostDate.getTime()); t > mapSettings.ghostRecoverTimer && (changeGhostType(e, "move"), e.active || gameData.mapLoop || releaseGhost(e)) } } else; } gameData.ghostBlinkSide = 1 != gameData.ghostBlinkSide } timeData.oldTimer = timeData.pillTimer } for (a = 0; a < gameData.users.length; a++) { var o = gameData.users[a]; if (o.active) { var n = movePacman(o); o.x = n.x, o.y = n.y, updateLabel(o); var r = o.direction; changePlayerAnimate(o, r) } } var i = new Date; for (a = 0; a < gameData.ghosts.length; a++) { e = gameData.ghosts[a], n = moveGhosts(e); e.x = n.x, e.y = n.y; var m = e.direction; if (timeData.pillEnable && ("hidden" == e.status ? m = "black" + e.direction : "eatable" == e.status && (m = "blue" + e.direction, gameData.ghostBlink && (e.recover || gameData.ghostBlinkSide || (m = "white" + e.direction)))), changeAnimate(e, m), e.active && !e.followPath && "move" == e.status && !timeData.pillEnable) for (var l = 0; l < gameData.users.length; l++) { o = gameData.users[l], t = Math.floor(i.getTime() - e.ghostDate.getTime()); if (t > 5e3 && (e.chaseUser = 1 != e.chaseUser, e.chaseUser = !1, e.ghostDate = new Date), e.chaseUser) { var s = getDistance(e.x, e.y, o.x, o.y); s <= 300 && (e.followPlayer = o, chaseUser(e)) } } } checkCollision(), loopGameMap(), checkControl() } if ("game" == curPage && "function" == typeof initSocket && multiplayerSettings.enable && socketData.online) { o = gameData.users[gameData.gameIndex]; if (o.active) { var p = { x: o.x, y: o.y, frame: o.currentFrame, scaleX: o.scaleX, rotation: o.rotation, labelX: o.nameLabel.x, labelY: o.nameLabel.y }, g = []; for (a = 0; a < gameData.ghosts.length; a++) { e = gameData.ghosts[a]; g.push({ x: e.x, y: e.y, frame: e.currentFrame }) } postSocketUpdate("updateplayer", { index: gameData.gameIndex, map: gameData.map, mapX: mapWrapContainer.x, mapY: mapWrapContainer.y, jumpCount: multiData.jumpCount, loopCount: multiData.loopCount, player: p, ghosts: g }, !0) } } } function updateLabel(a) { a.nameLabel.x = a.x, a.nameLabel.y = a.y - gameData.labelDistance } function loopGameMap() { multiData.jumpCount++; var a = ""; gameData.mapLoop && ("down" == gameData.mapLoopDirection ? (mapWrapContainer.y += gameData.mapLoopSpeed, mapWrapContainer.y + gameData.squareSize > 0 && (a = "row")) : "up" == gameData.mapLoopDirection ? (mapWrapContainer.y -= gameData.mapLoopSpeed, mapWrapContainer.y < -2 * gameData.squareSize && (a = "row")) : "left" == gameData.mapLoopDirection ? (mapWrapContainer.x += gameData.mapLoopSpeed, mapWrapContainer.x + gameData.squareSize > 0 && (a = "column")) : "right" == gameData.mapLoopDirection && (mapWrapContainer.x -= gameData.mapLoopSpeed, mapWrapContainer.x < -2 * gameData.squareSize && (a = "column"))), "" != a && ("function" == typeof initSocket && multiplayerSettings.enable && socketData.online && postSocketUpdate("checkmapend"), updateMapEnd(a)) } function updateMapEnd(a) { "row" == a ? (checkLoopLevel(), changeMapRow()) : (checkLoopLevel(), changeMapColumn()), multiData.jumpCount = 0, multiData.loopCount++ } function checkLoopLevel() { gameData.pillTarget++, gameData.collectionTarget++; var a = gameData.level; if (a < mapSettings.loop.levels.length) if ("function" == typeof initSocket && multiplayerSettings.enable && socketData.online) { for (var e = !1, t = 0; t < socketData.players.length; t++)socketData.players[t].score >= mapSettings.loop.levels[a].scoreTarget && (e = !0); e && showGameStage("clear") } else playerData.score >= mapSettings.loop.levels[a].scoreTarget && showGameStage("clear") } function getLevelSettings() { var a = gameData.level; a = a > mapSettings.loop.levels.length - 1 ? mapSettings.loop.levels.length - 1 : a, gameData.mapLoopSpeed = mapSettings.loop.levels[a].mapSpeed, gameData.userSpeed = mapSettings.loop.levels[a].userSpeed, gameData.ghostSpeed = mapSettings.loop.levels[a].ghostSpeed, gameData.ghostEatenSpeed = mapSettings.loop.levels[a].ghostEatenSpeed, gameData.ghostEatableSpeed = mapSettings.loop.levels[a].ghostEatableSpeed } function changeGhostType(a, e) { a.status = e, "hidden" == e ? a.ghostDate = new Date : "eatable" == e && ("base" == !a.followPathType && (a.followPath = !1, a.followPathType = ""), a.recover = !1, a.status = "eatable", a.direction = oppositeDirection(a.direction)) } function checkCollision() { for (var a = 0; a < gameData.ghosts.length; a++)for (var e = gameData.ghosts[a], t = 0; t < gameData.users.length; t++) { var o = gameData.users[t]; if (collided(o, e) && !o.invisible && o.active) if ("eatable" == e.status) { changeGhostType(e, "hidden"), playSound("soundEatGhost"), toggleGameSound(""), gameData.paused = !0; var n = .5; gameData.mapLoop ? "function" == typeof initSocket && multiplayerSettings.enable && socketData.online && (n = 0) : (e.followPath = !0, e.followPathType = "base", e.targetPath = [gameData.ghostStayPos[gameData.ghostStayPosIndex][0], gameData.ghostStayPos[gameData.ghostStayPosIndex][1]], getTargetPath(e), gameData.ghostStayPosIndex++, gameData.ghostStayPosIndex = gameData.ghostStayPosIndex > gameData.ghostStayPos.length - 1 ? 0 : gameData.ghostStayPosIndex), addScore(mapSettings.score.ghost, o.index), TweenMax.to(gameStatusTxt, n, { overwrite: !0, onComplete: function () { gameData.paused = !1, toggleGameSound("eaten") } }) } else "move" == e.status && pacmanDie(o.index) } } function pacmanDie(a) { var e = gameData.users[a]; e.active && (stopGame(), gameData.users[a].gotoAndPlay("die"), playSound("soundFail"), TweenMax.to(gameContainer, 2, { overwrite: !0, onComplete: function () { if ("function" == typeof initSocket && multiplayerSettings.enable && socketData.online) { var e = socketData.players.findIndex(e => e.gameIndex === a); socketData.players[e].lives--; var t = gameData.users[a]; if (t.active = !1, !gameData.mapLoop) if (socketData.players[e].lives > 0) { resetPacman(a), t.invisibleCount = 16, t.invisible = !0, animateInvisiblePacman(t); for (var o = 0; o < gameData.users.length; o++) { var n = gameData.users[o]; n.invisibleCount > 0 && o != a && (n.invisible = !0, animateInvisiblePacman(n)) } } else gameData.users[a].nameLabel.text = ""; if (postSocketUpdate("updatestats", { index: e, score: socketData.players[e].score, lives: socketData.players[e].lives }), updateGameDisplay(), socketData.players[e].lives <= 0) { for (o = 0; o < gameData.ghosts.length; o++) { var r = gameData.ghosts[o]; r.visible = !1 } toggleGameSound(""), playSound("soundDead"), showGameStatus("over"), postSocketUpdate("endgame") } else gameData.paused = !1, toggleGameTimer(!0), toggleGameSound("normal") } else gameData.mapLoop ? endGame() : (gameData.lives--, updateGameDisplay(), gameData.lives <= 0 ? endGame() : showGameStage("ready")) } })) } function animateInvisiblePacman(a) { a.invisibleCount--, a.alpha = isEven(a.invisibleCount) ? 1 : .5, a.invisibleCount > 0 ? TweenMax.to(a, .2, { overwrite: !0, onComplete: function () { animateInvisiblePacman(a) } }) : (a.invisibleCount = 0, a.alpha = 1, a.invisible = !1) } function collided(a, e) { return Math.sqrt(Math.pow(e.x - a.x, 2) + Math.pow(e.y - a.y, 2)) < 2 * gameData.monsterSize } function changeAnimate(a, e) { a.spriteDirection != e && (a.spriteDirection = e, a.gotoAndPlay(e)) } function changePlayerAnimate(a, e) { if (!gameData.paused && a.spriteDirection != e) { a.spriteDirection = e; var t = "eat"; "" == e ? t = "stay" : (a.scaleX = 1, a.rotation = 0, "left" == e ? a.scaleX = -1 : "up" == e ? (a.scaleX = -1, a.rotation = 0) : "down" == e && (a.rotation = 0)), a.gotoAndPlay(t) } } function toggleTouchAlpha(a, e) { a.alpha = e ? .6 : 1 } function setupTouchControl() { for (var a = ["Up", "Right", "Down", "Left"], e = 0; e < a.length; e++)$.touch["arrow" + a[e]].id = a[e].toLowerCase(), $.touch["arrow" + a[e]].addEventListener("mousedown", function (a) { toggleTouchArrow(a.target.id, !0), gameData.moveControl[a.target.id] = !0 }), $.touch["arrow" + a[e]].addEventListener("pressup", function (a) { toggleTouchArrow(a.target.id, !1), gameData.moveControl[a.target.id] = !1 }); buttonTouchMove.cursor = "pointer", buttonTouchMove.addEventListener("mousedown", function (a) { toggleMoveEvent(a, "drag") }), buttonTouchMove.addEventListener("pressmove", function (a) { toggleMoveEvent(a, "move") }), buttonTouchMove.addEventListener("pressup", function (a) { toggleMoveEvent(a, "drop") }) } function toggleMoveEvent(a, e) { switch (e) { case "drag": var t = touchMoveContainer.localToGlobal(a.currentTarget.x, a.currentTarget.y); a.currentTarget.offset = { x: t.x - a.stageX, y: t.y - a.stageY }; break; case "move": var o = touchMoveContainer.globalToLocal(a.stageX, a.stageY), n = o.x + a.currentTarget.offset.x, r = o.y + a.currentTarget.offset.y, i = dragLimit(n, r); a.currentTarget.x = i.x, a.currentTarget.y = i.y; var m = 10; gameData.moveControl.up = !1, gameData.moveControl.left = !1, gameData.moveControl.right = !1, gameData.moveControl.down = !1, toggleTouchArrow("left", !1), toggleTouchArrow("right", !1), toggleTouchArrow("up", !1), toggleTouchArrow("down", !1), a.currentTarget.x <= -m && (gameData.moveControl.left = !0, toggleTouchArrow("left", !0)), a.currentTarget.x >= m && (gameData.moveControl.right = !0, toggleTouchArrow("right", !0)), a.currentTarget.y <= -m && (gameData.moveControl.up = !0, toggleTouchArrow("up", !0)), a.currentTarget.y >= m && (gameData.moveControl.down = !0, toggleTouchArrow("down", !0)); break; case "drop": gameData.moveControl.up = !1, gameData.moveControl.left = !1, gameData.moveControl.right = !1, gameData.moveControl.down = !1, resetControlUI() } } function dragLimit(a, e) { var t = 20, o = dragDistance([a, e], [0, 0]); if (o <= t) return { x: a, y: e }; a -= 0, e -= 0; var n = Math.atan2(e, a); return { x: Math.cos(n) * t + 0, y: Math.sin(n) * t + 0 } } function dragDistance(a, e) { var t = a[0], o = a[1], n = e[0], r = e[1]; return Math.sqrt(Math.pow(t - n, 2) + Math.pow(o - r, 2)) } function resetControlUI() { toggleTouchArrow("up", !1), toggleTouchArrow("down", !1), toggleTouchArrow("left", !1), toggleTouchArrow("right", !1), buttonTouchMove.x = buttonTouchMove.y = 0 } function toggleTouchArrow(a, e) { a = capitalizeFirstLetter(a), a && (e ? ($.touch[a].visible = !0, $.touch["arrow" + a].visible = !1) : ($.touch[a].visible = !1, $.touch["arrow" + a].visible = !0)) } function capitalizeFirstLetter(a) { return a.charAt(0).toUpperCase() + a.slice(1) } function endGame() { stopGame(), toggleGameSound(""), playSound("soundDead"), showGameStatus("over"), $.editor.enable || TweenMax.to(gameContainer, 2, { overwrite: !0, onComplete: function () { goPage("result") } }) } function millisecondsToTimeGame(a) { var e = Math.floor(a / 1e3 % 60), t = Math.floor(a / 6e4 % 60); return e < 10 && (e = "0" + e), t < 10 && (t = "0" + t), t + ":" + e } function toggleOption() { optionsContainer.visible ? optionsContainer.visible = !1 : optionsContainer.visible = !0 } function toggleSoundMute(a) { buttonSoundOff.visible = !1, buttonSoundOn.visible = !1, toggleSoundInMute(a), a ? buttonSoundOn.visible = !0 : buttonSoundOff.visible = !0 } function toggleMusicMute(a) { buttonMusicOff.visible = !1, buttonMusicOn.visible = !1, toggleMusicInMute(a), a ? buttonMusicOn.visible = !0 : buttonMusicOff.visible = !0 } function toggleFullScreen() { document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement ? document.exitFullscreen ? document.exitFullscreen() : document.msExitFullscreen ? document.msExitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitExitFullscreen && document.webkitExitFullscreen() : document.documentElement.requestFullscreen ? document.documentElement.requestFullscreen() : document.documentElement.msRequestFullscreen ? document.documentElement.msRequestFullscreen() : document.documentElement.mozRequestFullScreen ? document.documentElement.mozRequestFullScreen() : document.documentElement.webkitRequestFullscreen && document.documentElement.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT) } function share(a) { gtag("event", "click", { event_category: "share", event_label: a }); var e = location.href; e = e.substring(0, e.lastIndexOf("/") + 1); var t = "", o = "", n = addCommas(Math.floor(playerData.score)); t = shareTitle.replace("[SCORE]", n), o = shareMessage.replace("[SCORE]", n); var r = ""; "twitter" == a ? r = "https://twitter.com/intent/tweet?url=" + e + "&text=" + o : "facebook" == a ? r = "https://www.facebook.com/sharer/sharer.php?u=" + encodeURIComponent(e + "share.php?desc=" + o + "&title=" + t + "&url=" + e + "&thumb=" + e + "share.jpg&width=590&height=300") : "google" == a ? r = "https://plus.google.com/share?url=" + e : "whatsapp" == a && (r = "whatsapp://send?text=" + encodeURIComponent(o) + " - " + encodeURIComponent(e)), window.open(r) } var theme_settings = [{ strokeColor: "#ccc", biscuitColor: "#EE9B33", pillColor: "#EE9B33", gateColor: "#5386F1", user: ["assets/item_user.png"], ghosts: ["assets/item_monster1.png", "assets/item_monster2.png", "assets/item_monster3.png", "assets/item_monster4.png", "assets/item_monster5.png", "assets/item_monster6.png", "assets/item_monster7.png"], collection: ["assets/item_ball.png"] }], mapSettings = { squareSize: 24, monsterSize: 5, biscuitSize: 2, pillSize: 5, design: { strokeNum: 3 }, showScreenControl: !0, screenControlSide: !0, screenControlAlpha: .6, keyboard: { left: [37, 65], right: [39, 68], up: [38, 87], down: [40, 83] }, mobileControl: "right", userSpeed: 2, ghostSpeed: 2, ghostEatenSpeed: 4, ghostEatableSpeed: 1, countdownTimer: 800, pillTimer: 1e4, ghostRecoverTimer: 5e3, ghostBlinkTimer: 300, collectShowTimer: 15e3, lives: 3, score: { biscuit: 10, pill: 50, ghost: 50, collection: 100 }, loop: { pillTarget: 5, collectionTarget: 15, levels: [{ mapSpeed: .5, userSpeed: 2, ghostSpeed: 2, ghostEatenSpeed: 4, ghostEatableSpeed: 1, scoreTarget: 800 }, { mapSpeed: 1, userSpeed: 2, ghostSpeed: 2, ghostEatenSpeed: 4, ghostEatableSpeed: 1, scoreTarget: 1500 }, { mapSpeed: 1.5, userSpeed: 3, ghostSpeed: 3, ghostEatenSpeed: 5, ghostEatableSpeed: 2, scoreTarget: 3e3 }, { mapSpeed: 2, userSpeed: 4, ghostSpeed: 4, ghostEatenSpeed: 6, ghostEatableSpeed: 3, scoreTarget: 4e3 }, { mapSpeed: 2.5, userSpeed: 4, ghostSpeed: 4, ghostEatenSpeed: 6, ghostEatableSpeed: 3, scoreTarget: 5e3 }, { mapSpeed: 3, userSpeed: 4, ghostSpeed: 4, ghostEatenSpeed: 6, ghostEatableSpeed: 3, scoreTarget: 6e3 }] } }, textDisplay = { gameReady: "GET READY!", gameReadyLevel: "LEVEL [NUMBER]", gameCountdown: ["1", "2", "3"], gameOver: "GAME OVER", gameClear: "LEVEL CLEAR", gameScore: "SCORE : [NUMBER]PTS", gameLevel: "LEVEL : [NUMBER]", multiplayerName: "P[NUMBER] : ", multiplayerIndicator: "P[NUMBER]", exitTitle: "Exit Game", exitMessage: "Are you sure you want\nto quit game?", share: "Share your score:", resultTitle: "GAME OVER", resultDesc: "[NUMBER]PTS" }, shareEnable = !0, shareTitle = "Highscore on MOG is [SCORE]pts", shareMessage = "[SCORE] points is my new highscore on @EightBitMog game! Try it now! $BITMOG #BITMOG"; $.editor = { enable: !1 }; var playerData = { score: 0 }, gameData = { paused: !0, mapNum: 0, themeNum: 0, playerIndex: 0, users: [], gameIndex: 0, ghosts: [], lives: 0, level: 0, ghostBlink: !1, ghostBlinkSide: !1, mapLoopSide: !0, labelDistance: 20 }, multiData = { alpha: .3, players: [], loopCount: 0, jumpCount: 0, map: 0 }, timeData = { enable: !1, startDate: null, nowDate: null, timer: 0, oldTimer: 0, pillEnable: !1, pillDate: null, pillTimer: 0, collecTimer: 0, accumulate: 0, accumulatePill: 0 }, tweenData = { score: 0, tweenScore: 0 }, mapType = { walls: [0, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 80], empty: 1, biscuit: 2, pill: 3, block: 4, gateHorizontal: 5, gateVertical: 6, collection: [100, 101, 102, 103, 104, 105, 106, 107, 108, 109] }, curPage = "";